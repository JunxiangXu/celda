# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

decontXEM <- function(counts, counts_colsums, theta, eta, phi, z, pseudocount) {
    .Call('_celda_decontXEM', PACKAGE = 'celda', counts, counts_colsums, theta, eta, phi, z, pseudocount)
}

decontXLogLik <- function(counts, theta, eta, phi, z, pseudocount) {
    .Call('_celda_decontXLogLik', PACKAGE = 'celda', counts, theta, eta, phi, z, pseudocount)
}

decontXInitialize <- function(counts, theta, z, pseudocount) {
    .Call('_celda_decontXInitialize', PACKAGE = 'celda', counts, theta, z, pseudocount)
}

calculateNativeMatrix <- function(counts, native_counts, theta, eta, phi, z, row_index, col_index, pseudocount) {
    .Call('_celda_calculateNativeMatrix', PACKAGE = 'celda', counts, native_counts, theta, eta, phi, z, row_index, col_index, pseudocount)
}

#' get row and column indices of none zero elements in the matrix
#' 
#' @param R_counts A matrix
#' @return An integer matrix where each row is a row, column indices pair 
nonzero <- function(R_counts) {
    .Call('_celda_nonzero', PACKAGE = 'celda', R_counts)
}

cG_calcGibbsProbY_Simple <- function(counts, nGbyTS, nTSbyC, nbyTS, nbyG, y, L, index, gamma, beta, delta) {
    .Call('_celda_cG_calcGibbsProbY_Simple', PACKAGE = 'celda', counts, nGbyTS, nTSbyC, nbyTS, nbyG, y, L, index, gamma, beta, delta)
}

cG_CalcGibbsProbY_ori <- function(index, counts, nTSbyC, nbyTS, nGbyTS, nbyG, y, L, nG, lg_beta, lg_gamma, lg_delta, delta) {
    .Call('_celda_cG_CalcGibbsProbY_ori', PACKAGE = 'celda', index, counts, nTSbyC, nbyTS, nGbyTS, nbyG, y, L, nG, lg_beta, lg_gamma, lg_delta, delta)
}

cG_CalcGibbsProbY_fastRow <- function(index, counts, nTSbyC, nbyTS, nGbyTS, nbyG, y, L, nG, lg_beta, lg_gamma, lg_delta, delta) {
    .Call('_celda_cG_CalcGibbsProbY_fastRow', PACKAGE = 'celda', index, counts, nTSbyC, nbyTS, nGbyTS, nbyG, y, L, nG, lg_beta, lg_gamma, lg_delta, delta)
}

cG_CalcGibbsProbY <- function(index, counts, nTSbyC, nbyTS, nGbyTS, nbyG, y, L, nG, lg_beta, lg_gamma, lg_delta, delta) {
    .Call('_celda_cG_CalcGibbsProbY', PACKAGE = 'celda', index, counts, nTSbyC, nbyTS, nGbyTS, nbyG, y, L, nG, lg_beta, lg_gamma, lg_delta, delta)
}

#' Fast matrix multiplication for double x int
#' 
#' @param A a double matrix
#' @param B an integer matrix
#' @return An integer matrix representing the product of A and B
eigenMatMultInt <- function(A, B) {
    .Call('_celda_eigenMatMultInt', PACKAGE = 'celda', A, B)
}

#' Fast normalization for numeric matrix
#' 
#' @param R_counts An integer matrix
#' @param R_alpha A double value to be added to the matrix as a pseudocount
#' @return A numeric matrix where the columns have been normalized to proportions
fastNormProp <- function(R_counts, R_alpha) {
    .Call('_celda_fastNormProp', PACKAGE = 'celda', R_counts, R_alpha)
}

#' Fast normalization for numeric matrix
#' 
#' @param R_counts An integer matrix
#' @param R_alpha A double value to be added to the matrix as a pseudocount
#' @return A numeric matrix where the columns have been normalized to proportions
fastNormPropLog <- function(R_counts, R_alpha) {
    .Call('_celda_fastNormPropLog', PACKAGE = 'celda', R_counts, R_alpha)
}

#' Fast normalization for numeric matrix
#' 
#' @param R_counts An integer matrix
#' @param R_alpha A double value to be added to the matrix as a pseudocount
#' @return A numeric matrix where the columns have been normalized to proportions
fastNormPropSqrt <- function(R_counts, R_alpha) {
    .Call('_celda_fastNormPropSqrt', PACKAGE = 'celda', R_counts, R_alpha)
}

